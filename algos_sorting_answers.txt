Exercises

1. Implement a solution for bubble sort.

function bubbleSort(collection){
 let swapped = false;
 while(swapped == false ){
  for(let i = 0; i < collection.length - 1; i++){
    if(collection[i] > collection[i + 1]){
     let temp = collection[i];
     collection[i] = collection[i + 1];
     collection[i + 1] = temp;
     swapped = true;
   }
  }
 }
 return collection;
}

console.log(bubbleSort([1, 4, 5, 10, 3, 8]))

2. Write a pseudocode for quicksort

Function Partition(collection, start, end)
SET pivot to last index in collection
SET pivotIndex to start
FOR each value in the collection
 IF the value is less than or equal to pivot
  SWITCH the value with the pivotIndex
  SET pivotIndex to pivotIndex + 1
END IF
END FOR
SWITCH pivotIndex value with end value

Function Quicksort(collection, start, end)
IF start is less than end
CALL Partition function 
CALL Quicksort to sort the left side of collection using pivotIndex - 1 for end
CALL Quicksort to sort the right side of the collection using pivotIndex + 1 for start
END IF

3. We talked about time complexity in a previous checkpoint, and how to get an idea of the 
efficiency of an algorithm. After looking at the pseudocode for the above sorting methods, 
identify why merge sort and quick sort are much more efficient than the others. 
Walking through each algorithm with a few sample collections may help.

A: Merge sort and quick sort are both more efficient because they use the divide and conquer approach,
splitting up collections into smaller ones and bringing them back together after its done being sorted. This
is faster than having to iterate through the collection over and over again.

4. All of the sorts addressed in this checkpoint are known as comparison sorts. Research bucket sort and explain how it works. 
What is the ideal input for bucket sort?

A: Bucket sorting places elements in bucket, sorts the elements in the buckets and then merges them. The ideal input
for bucket sort would be data that can be uniformly distributed throughout the buckets.




